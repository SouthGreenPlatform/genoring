#!/usr/bin/env perl

=pod

=head1 NAME

genoring.pl - Manages GenoRing platform

=head1 SYNOPSIS

    ./genoring.pl start

=head1 REQUIRES

Perl5

=head1 DESCRIPTION

Manages GenoRing features.

=cut

use strict;
use warnings;

use Getopt::Long;
use Pod::Usage;
use File::Basename;

++$|; #no buffering




# Script global constants
##########################

=pod

=head1 CONSTANTS

B<$REV_STRING>: (integer)

Current revision (auto-set by SVN when the appropriate property has been set).

B<$DEBUG>: (boolean)

When set to true, it enables debug mode.

B<$CONSTANT_NAME>: ([constant nature]) #+++

[constant description and use]. #+++

=cut

our $GENORING_VERSION = '1.0';

our $DEBUG = 0;

our $BASEDIR = dirname(__FILE__);
our $DOCKER_COMPOSE_FILE = 'docker-compose.yml';
our $MODULE_FILE = 'modules.conf';
our $MODULE_DIR = 'modules';




# Script global variables
##########################

=pod

=head1 VARIABLES

B<[g_variable_name]>: ([variable nature]) #+++

[variable description, use and default value]. #+++
Default: [variable default value if one] #+++

#--- Example:
#--- B<$g_output_method>: (integer)
#---
#--- used to store current output method;
#--- 0=raw text (default), 1=image, 2=html.
#---
#---     ...
#---
#--- my $g_output_method = 0;
#---

=cut

#+++ my [$g_variable_name] = ["value"];




# Script global functions
##########################

=pod

=head1 FUNCTIONS

=head2 [SubName] #+++

B<Description>: [function description]. #+++

B<ArgsCount>: [count of arguments] #+++

=over 4

=item $variable_name: ([variable nature]) ([requirements]) #+++ see below

#--- requirement can be:
#--- (R)=required,
#--- (O)=optional
#--- (U)=optional and must be undef if omitted
[variable description]. #+++

=item $variable_name2: ([variable nature]) ([requirements]) #+++

[variable description]. #+++

=back

B<Return>: ([return type]) #+++

[return description]. #+++

B<Example>:

    [example code] #+++

=cut

sub StartGenoring {
  # Check if setup needs to be run first.
  my $modules = {};
  if (!-e $MODULE_FILE) {
    my $module_fh;
    if (open($module_fh, ">$MODULE_FILE")) {
      print {$module_fh} "genoring\n";
      close($module_fh);
      $modules = {
        'genoring' => 'genoring',
      };
    }
    else {
      die "ERROR: failed to open module file '$MODULE_FILE':\n$!\n";
    }
  }
  else {
    # Get enabled modules.
    my $module_fh;
    if (open($module_fh, $MODULE_FILE)) {
      while (<$module_fh>) {
        $_ =~ s/^\s+|\s+$//g;
        $modules->{$_} = $_;
      }
      close($module_fh);
    }
    else {
      die "ERROR: failed to open module file '$MODULE_FILE':\n$!\n";
    }
  }

  if (!-e $DOCKER_COMPOSE_FILE) {
    # Needs first-time initialization.
    # @todo
    # Generate docker-compose.yml...
    my $file_handle;
    if (open($file_handle, ">$DOCKER_COMPOSE_FILE")) {
      print {$file_handle} "# GenoRing docker compose file\n# WARNING: This file is auto-generated by genoring.sh script. Any direct\n# modification may be lost when genoring.sh will need to regenerate it.\n\nservices:\n";
      close($file_handle);
    }
    else {
      die "ERROR: failed to open module file '$MODULE_FILE':\n$!\n";
    }
    # Generate "services" and "volumes" sections from enabled services...
    # For each enabled service, add the section name and the 'container_name:'
    # field and indent. Also make sure there is a version.
    # Add other modules to genoring container dependencies (depends_on:).

    # For volumes, keep track of added volumes and check version when redondant
    # to keep the most recent unless a major version incompatibility.
    # Add the section name and the 'name:' field and indent.

    # Apply global initialization hooks (modules/*/hooks/init.pl).
    # Set genoring (Drupal) maintenance mode in genoring.env (DRUPAL_MAINTENANCE=1).
    # Start dockers.
    # Check dockers are ready.
    # Apply docker initialization hooks of each enabled module for each
    # enabled module (ie. modules/"ext1"/hooks/init_"ext2".sh).
    # Clear genoring maintenance mode.
  }
  # docker compose up -d
}

sub StopGenoring {
  # docker compose down
}

sub StopGenoring {
}

sub GetStatus {
}

sub GetLogs {
  # docker compose logs -f
}

# Removes Drupal files and database data for a full reinstall.
sub Reinitialize () {
  # assert_root
  # # @todo Warn and ask for confirmation.
  # stop_genoring
  # docker container prune -f
  # docker volume rm genoring-drupal
  # # @todo Check if only a sub-part should be managed.
  # # @todo Add an option to remove ALL and not just Drupal and its db.
  # rm -rf volumes/drupal
  # # rm -rf volumes/data
  # rm -rf volumes/db
  # # @todo Clear enabled modules.
  # mkdir -p volumes/drupal
  # mkdir -p volumes/data
}

# Initializes GenoRing system with user inputs.
sub SetupGenoring {
  # mkdir -p volumes/drupal
  # mkdir -p volumes/data
  # # @toto Manage environment file generation.
  # # Ask for ...
  # while [ -z "$value" ]; do
  #   read -p "Enter a value: " value
  # done
  # 
  # # @todo Check for modules to enable.
  # # docker exec -v ./modules/profile/path/to/:/path/to/ -it genoring /path/to/script.sh
  # # @toto Ask to start genoring.
  # start_genoring
}

##
# Updates the GenoRing system or the specified module.
#
# Arguments:
#  service (optional): the service/module to update. If not set, all is
#    updated.
#
sub Update () {
  # @todo Check if running.
  # @todo Check if only some parts should be updated or update all.
  # docker compose run -e DRUPAL_UPDATE=2 genoring
}

##
# Enables the given GenoRing module.
#
# Arguments:
#  module: the module to enable and setup.
#
sub InstallModule {
  # Check if the system is running and stop it.
  # Set maintenance mode.
  # Perform install.
  # Start the system.
  # Perform container installations.
  # Stop the system if it was not started.
  
  # if [ -z $1 ]; then
  #   >&2 echo "ERROR: genoring_enable: No module name provided!"
  #   exit 1
  # fi
  # # Get module status.
  # get_module_status $1
  # if [ -z "$module_status" ]; then
  #   >&2 echo "ERROR: genoring_enable: module not found ($1)!"
  #   exit 1
  # elif [ "0" == "$module_status" ]; then
  #   # Enable specified modules.
  #   # Add module to the enabled module file.
  #   echo "$1" >> ./enabled_modules.txt
  #   # Copy nginx config.
  #   if [ -e "./modules/$1/nginx/$1.conf" ]; then
  #     # Do not overwrite existing.
  #     cp -n "./modules/$1/nginx/$1.conf" ./proxy/modules/
  #   fi
  #   # Call init scripts.
  #   echo "Initializing..."
  #   if [ -x "./modules/$1/hooks/init.sh" ]; then
  #     echo "- $1"
  #     ./modules/$1/hooks/init.sh
  #   fi
  #   if [ -d "./modules/$1/hooks" ]; then
  #     # Loop on docker initialization scripts.
  #     for scriptname in modules/$1/hooks/init_*.sh; do
  #       # When no files found, continue.
  #       [ -e "$scriptname" ] || continue
  #       container_name=$(echo $scriptname | perl -p -e "s#modules/$1/hooks/init_(.+)\.sh#\$1#g")
  #       # Check if the corresponding container is running.
  #       container_is_running $container_name
  #       if [ ! -z "$container_is_running" ]; then
  #         echo "- $container_name"
  #         docker exec -v ./modules/$1/hooks/init_$container_name.sh:/usr/init/init_$container_name.sh -it $container_name /user/init/init_$container_name.sh
  #       fi
  #     done
  #   fi
  #   echo "...initialization done."
  # elif [ "1" == "$module_status" ]; then
  #   echo "WARNING: genoring_enable: module already enabled ($1)."
  # fi
}

##
# Disables and uninstalls the given GenoRing module.
#
# Arguments:
#  module: the module to disable and uninstall.
# @todo Maybe see if uninstall could be optional.
#
sub UninstallModule {
  # assert_root
  # # @todo Warn and ask for confirmation.
  # if [ -z $1 ]; then
  #   >&2 echo "ERROR: genoring_disable: No module name provided!"
  #   exit 1
  # fi
  # # Get module status.
  # get_module_status $1
  # if [ -z "$module_status" ]; then
  #   >&2 echo "ERROR: genoring_disable: module not found ($1)!"
  #   exit 1
  # elif [ "1" == "$module_status" ]; then
  #   # Disable specified modules.
  #   # Remove module from the enabled module file.
  #   perl -p -i -e "s/^\\s*\\Q$1\\E\\s*\$//g" ./enabled_modules.txt
  #   # Remove nginx config.
  #   if [ -e "./proxy/modules/$1.conf" ]; then
  #     rm ./proxy/modules/$1.conf 
  #   fi
  #   # Call uninstall scripts.
  #   echo "Uninstalling..."
  #   if [ -x "./modules/$1/hooks/uninstall.sh" ]; then
  #     echo "- $1"
  #     ./modules/$1/hooks/uninstall.sh
  #   fi
  #   if [ -d "./modules/$1/hooks" ]; then
  #     # Loop on docker uninstallation scripts.
  #     for scriptname in ./modules/$1/hooks/uninstall_*.sh; do
  #       # When no files found, continue.
  #       [ -e "$scriptname" ] || continue
  #       container_name=$(echo $scriptname | perl -p -e "s#modules/$1/hooks/uninstall_(.+)\.sh#\$1#g")
  #       # Check if the corresponding container is running.
  #       container_is_running $container_name
  #       if [ ! -z "$container_is_running" ]; then
  #         echo "- $container_name"
  #         docker exec -v ./modules/$1/hooks/uninstall_$container_name.sh:/usr/init/uninstall_$container_name.sh -it $container_name /user/init/uninstall_$container_name.sh
  #       fi
  #     done
  #   fi
  #   echo "...uninstallation done."
  # elif [ "0" == "$module_status" ]; then
  #   echo "WARNING: genoring_disable: module already disabled ($1)."
  # fi
}

##
# Performs a general backup of the GenoRing system into an archive file.
#
sub Backup {
  # @todo Backup config and data to an archive.
}

##
# Restores GenoRing from a given backup archive.
sub Restore {
  # @todo Restore a given backup archive.
}

##
# Recompiles a given container.
#
# Arguments:
#  $1: Container image name.
#  $2: Container source path where the Dockerfile is.
#  $3: (optional) Container name.
#
sub Recompile () {
  # if [ -z $1 ]; then
  #   >&2 echo "ERROR: genoring_recompile: Container image name not provided!"
  #   exit 1
  # elif [ -z $2 ]; then
  #   >&2 echo "ERROR: genoring_recompile: Container source path not provided!"
  #   exit 1
  # elif [ ! -e $2 ]; then
  #   >&2 echo "ERROR: get_env_setting: Container source path not found ($2)!"
  #   exit 1
  # fi
  # if [ -z $3 ]; then
  #   set -- $1 $2 $1
  # fi
  # # Test if container is running and if so, stop it and rerun it after.
  # container_is_running $3
  # if [ ! -z "$container_is_running" ]; then
  #   echo "WARNING: genoring_recompile: The container was running and will be stopped."
  #   docker stop $3
  #   docker container prune -f
  # fi
  # docker image rm $1
  # docker image prune -f
  # docker build -t $1 $2
}

##
# Returns a list of GenoRing modules.
#
# Arguments:
#  status (optional): if non-zero, only returns enabled modules, if 0 only
#    returns disabled available modules and if not set, returns all available
#    modules.
#
sub Getmodules {
  # if [ -z $1 ]; then
  #   find modules -mindepth 1 -maxdepth 1 -type d -printf "%f\n"
  # elif [ "0" == "$1" ]; then
  #   find modules -mindepth 1 -maxdepth 1 -type d -printf "%f\n" | grep -v -x -f ./enabled_modules.txt
  # elif [ "1" == "$1" ]; then
  #   cat ./enabled_modules.txt
  # fi
}

##
# Returns the status of a GenoRing modules.
#
# Arguments:
#   $1: the name of the module.
#
# Return:
#   Sets the variable 'module_status' to an empty value if the module was
#   not found (ie. does not exist), 0 if the module is disabled and 1 if the
#   module is enabled.
#
sub GetmoduleStatus {
  # if [ -z $1 ]; then
  #   >&2 echo "ERROR: get_module_status: No module name provided!"
  #   exit 1
  # fi
  # module_status=
  # if [ ! -z "$(grep -x $1 ./enabled_modules.txt)" ]; then
  #   module_status=1
  # elif [ ! -z $(find modules -mindepth 1 -maxdepth 1 -type d -printf "%f\n" | grep -v -x $1) ]; then
  #   module_status=0
  # fi
}

##
# Returns the value of an environment variable in an env file.
#
# Arguments:
#   $1: environment file path.
#   $2: setting variable name.
#
# Return: 
#   Sets the variable 'env_value'.
#
sub GetEnvVariable {
  # env_value=
  # if [ -z $1 ]; then
  #   >&2 echo "ERROR: get_env_setting: Environment file not provided!"
  #   exit 1
  # elif [ ! -f $1 ]; then
  #   >&2 echo "ERROR: get_env_setting: Environment file not found ($1)!"
  #   exit 1
  # elif [ -z $2 ]; then
  #   >&2 echo "ERROR: get_env_setting: No setting variable requested!"
  #   exit 1
  # fi
  # env_value=$(grep -P "^\s*$2\s*[=:]" $1 | sed -r "s/\s*$2\s*[=:]\s*//" | sed -r "s/^'(.*)'\\s*\$|^\"(.*)\"\\s*\$/\1\2/" | tail -n 1)
}

##
# Sets the value of an environment variable in a given env file.
#
# Arguments:
#   $1: environment file path.
#   $2: setting variable name.
#   $3: new setting variable value.
#
sub SetEnvVariable {
  # if [ -z $1 ]; then
  #   >&2 echo "ERROR: set_env_setting: Environment file not provided!"
  #   exit 1
  # elif [ ! -f $1 ]; then
  #   >&2 echo "ERROR: set_env_setting: Environment file not found ($1)!"
  #   exit 1
  # elif [ -z $2 ]; then
  #   >&2 echo "ERROR: set_env_setting: No setting variable requested!"
  #   exit 1
  # fi
  # # Check if setting is there.
  # if [ -z "$(grep -P "\s*$2\s*[=:]" $1)" ]; then
  #   echo "\n$2=$3" >> $1
  # else
  #   perl -p -i -e "s/\s*\Q$2\E\s*[=:].*/$2=$3/g" $1
  # fi
}

##
# Tells if a container is running.
#
# Arguments:
#  $1: container_name
#
# Return:
#   Sets 'container_is_running' value to an empty value if not running or to
#   a non-empty string otherwise.
sub IsContainerRunning {
  # if [ -z "$1" ]; then
  #   >&2 echo "WARNING: container_is_running: No container name provided."
  #   container_is_running=
  #   return
  # fi
  # container_is_running=$(docker ps | grep -P "\s\Q$1\E(?:\s|$)")
}


# Script options
#################

=pod

=head1 OPTIONS

#--- describes parameters given to the script
#+++ command line syntax
#--- requirement of the option and its parameter can be:
#--- required: name or nature inside <>
#--- optional: name or nature inside []
#--- alternative between 2 elements: elements separated by a |

=head2 Parameters

=over 4

#+++=item B<-help>:
#+++
#+++Prints a brief help message and exits.
#+++
#+++=item B<-man>:
#+++
#+++Prints the manual page and exits.
#+++
#+++=item B<-debug> (integer):
#+++
#+++Executes the script in debug mode. The integer value is optional and is used
#+++to set debug level (use 0 to force disable debug mode).
#+++Default: 0 (not in debug mode).
#+++

=item B<[option_name]> ([option nature]): #+++

[option description]. #+++
Default: [option default value if one] #+++

#--- remove if log not used
#+++=item B<-log>:
#+++
#+++Enable logging.
#+++
#+++=item B<-log-*> (any):
#+++
#+++Logging arguments.

=back
#--- Example:
#---
#--- Template.pl [-help | -man]
#---
#--- Template.pl [-debug [debug_level]] [-size <width> [height]]
#---
#--- =over 4
#---
#--- =item B<-help>:
#---
#--- Prints a brief help message and exits.
#---
#--- =item B<-man>:
#---
#--- Prints the manual page and exits.
#---
#--- =item B<-debug> (integer):
#---
#--- Executes the script in debug mode. If an integer value is specified, it will
#--- be the debug level. If "-debug" option was used without specifying a debug
#--- level, level 1 is assumed.
#--- Default: 0 (not in debug mode).
#---
#---=item B<-size> (positive_real) (positive_real):
#---
#--- Set the dimensions of the object that will be drawn. The first value is
#--- the width; the height is the second value if specified, otherwise it will
#--- assume height and width are equal to the first value.
#--- Default: width and height are set to 1.
#---
#---=back

=cut


# CODE START
#############

# options processing
my ($man, $help, $debug, $no_prompt) = (0, 0, undef, undef);
# parse options and print usage if there is a syntax error.
GetOptions('help|?'     => \$help,
           'man'        => \$man,
           'debug:s'    => \$debug,
           'q|noprompt' => \$no_prompt,
           'length|l=i' => \$length, # numeric specified either with "-length 42" or "-l 42"
           'file=s'     => \$data, # a string
           'files=s{,}' => \@files, # a set of strings specified either with "-files toto tutu" or "-files toto -files tutu"
           'flag!'      => \$flag, # a flag wich can set or unset with "--flag" (set) or "--noflag" (unset) or "--no-flag" (unset)
           @Greenphyl::Log::LOG_GETOPT, # skip log parameters
) or pod2usage(1);
if ($help) {pod2usage('-verbose' => 1, '-exitval' => 0);}
if ($man) {pod2usage('-verbose' => 2, '-exitval' => 0);}

# change debug mode if requested/forced
if (defined($debug))
{
    # just '-debug' ?
    if ($debug eq '')
    {
        $debug = 1;
    }
    $DEBUG = $debug;
}

#--- opening a file when not using 'Fatal' lib:
#+++ my $file_handle;
#+++ if (open($file_handle, '>file.txt'))
#+++ {
#+++     ...
#+++     print {$file_handle} 'some text';
#+++     close($file_handle);
#+++ }
#+++ else
#+++ {
#+++     die "ERROR: failed to open file:\n$!\n";
#+++ }

#--- "try-catch" statement:
#--- # try:
#--- eval
#--- {
#---     ...
#---     if (...)
#---     {
#---         Throw('error' => 'I got this error message!', 'log' => 'and that is for log only');
#---     }
#--- };
#---
#--- # catch
#--- HandleErrors();
#--- Other possibility for specific catch needs:
#--- my $error;
#--- if ($error = Exception::Class->caught('Greenphyl::Error'))
#--- {...GreenPhyl excpetion...}
#--- elsif ($error = Exception::Class->caught())
#--- {...otherwise...}
#--- else
#--- {...no exception...}

#... #+++

exit(0);

__END__
# CODE END
###########

=pod

=head1 DIAGNOSTICS

#--- Give and explain here every error message the the script may generate.
#--- Use: (W)=warning (optional), (D)=deprecation (optional),
#---      (S)=severe warning (mandatory), (F)=fatal error (trappable),
#---      (X)=very fatal error (non-trappable).
#--- example:
#---
#--- =over 4
#---
#--- =item *
#---
#--- Negative radius;
#--- (F) Can not draw a circle with a negative radius.
#---
#---=back #+++

=head1 AUTHORS

Valentin GUIGNON (Bioversity), v.guignon@cgiar.org

=head1 VERSION

Version 1.0

Date 12/07/2024

=head1 SEE ALSO

GenoRing documentation (README.md).

=cut
